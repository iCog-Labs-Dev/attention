#include <cxxtest/TestSuite.h>
#include <opencog/atomspace/AtomSpace.h>
#include <opencog/attentionbank/bank/AttentionBank.h>
#include <opencog/cogserver/server/CogServer.h>
#include <opencog/cogserver/modules/agents/AgentsModule.h>
#include <opencog/cogserver/modules/agents/Scheduler.h>
#include <opencog/util/Config.h>
#include <algorithm>
#include <chrono>
#include <thread>

// Include the header for the agent under test
#include "WARentCollectionAgent.h"

using namespace opencog;
using namespace std;
using namespace std::chrono;

class WARentCollectionAgentUTest : public CxxTest::TestSuite {
private:
    AtomSpace* as;
    WARentCollectionAgent* _warent_agent;
    CogServer* _cogserver;
    Scheduler* _scheduler;
    AttentionBank* _attention_bank;
    
public:
    void setUp() {
        // Initialize CogServer and modules.
        _cogserver = &cogserver();
        config().set("MODULES", "opencog/attention/libattention.so");
        _cogserver->loadModules();
        config().set("MODULES", "libagents.so");
        
        Module* amod = _cogserver->getModule("opencog::AgentsModule");
        AgentsModule* agmod = static_cast<AgentsModule*>(amod);
        
        // Obtain the AtomSpace
        as = &_cogserver->getAtomSpace();
        _attention_bank = &attentionbank(as);
        
        // Initialize the WARentCollectionAgent
        _warent_agent = new WARentCollectionAgent(*_cogserver);
        
        // Register the agent with the Scheduler
        _scheduler = &agmod->get_scheduler();
        AbstractFactory<Agent>* warentFactory = new Factory<WARentCollectionAgent, Agent>;
        _scheduler->registerAgent(WARentCollectionAgent::info().id, warentFactory);
        
        std::cout << "WARentCollectionAgent registered" << std::endl;
    }
    
    void tearDown() {
        delete _warent_agent;
        _cogserver->stop();
        std::cout << "TearDown completed for WARentCollectionAgentUTest." << std::endl;
    }
    
    // Test that selectTargets returns a valid (non-undefined) atom.
    void testSelectTargets() {
        // Create a few atoms in the AtomSpace.
        Handle a = as->add_node(CONCEPT_NODE, "node1");
        Handle b = as->add_node(CONCEPT_NODE, "node2");
         Handle c = as->add_node(CONCEPT_NODE, "node3");
        // Do not add them to attentional focus so they are candidates for selection.
        
        // Call selectTargets; WARentCollectionAgent is designed to return a single random atom not in AF.
        HandleSeq targetSet;
        _warent_agent->selectTargets(targetSet);
        
        // Expect one valid target.
        TS_ASSERT_EQUALS(targetSet.size(), 1);
        Handle h = targetSet[0];
        TS_ASSERT((h == a) || (h == b)|| (h == c));
        std::cout << "testSelectTargets passed" << std::endl;
    }
    
    // Test that collectRent reduces the STI and LTI values.
    void testCollectRent() {
        // Create a sample atom and set initial attention values.
        Handle a = as->add_node(CONCEPT_NODE, "RentNode1");
        double initialSTI = 100.0;
        double initialLTI = 100.0;
        _attention_bank->set_sti(a, initialSTI);
        _attention_bank->set_lti(a, initialLTI);
        
        // Build a target set containing this atom.
        HandleSeq targetSet = { a };
        
        // For WARentCollectionAgent, collectRent uses an elapsed time from _sdac.
        // We assume that elapsed_time(h) returns a factor > 0. In a test environment,
        // if needed, you can override or simulate _sdac.elapsed_time(h). For now, we assume
        // the default behavior reduces the values.
        _warent_agent->collectRent(targetSet);
        
        // Retrieve the new attention values.
        double newSTI = _attention_bank->get_sti(a);
        double newLTI = _attention_bank->get_lti(a);
        
        TS_ASSERT_LESS_THAN(newSTI, initialSTI);
        TS_ASSERT_LESS_THAN(newLTI, initialLTI);
        std::cout << "STI after rent collection: " << newSTI << std::endl;
        std::cout << "LTI after rent collection: " << newLTI << std::endl;
        std::cout << "testCollectRent passed" << std::endl;
    }
};
