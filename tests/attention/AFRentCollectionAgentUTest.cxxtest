


#include <cxxtest/TestSuite.h>

#include <opencog/attention/AFRentCollectionAgent.h>
#include <opencog/cogserver/modules/agents/Scheduler.h>
#include <opencog/cogserver/server/CogServer.h>
#include <opencog/attentionbank/bank/AttentionBank.h>
#include <opencog/attentionbank/avalue/AttentionValue.h>
#include <opencog/atomspace/AtomSpace.h>
#include <opencog/util/Config.h>
#include <opencog/cogserver/modules/agents/AgentsModule.h>


using namespace opencog;

using namespace std;


class AFRentCollectioAgentUTest : public CxxTest::TestSuite
{
    private:
        AtomSpace* as;
        AFRentCollectionAgent* _afrentcollection_agent;
        CogServer* _cogserver;
        Scheduler* _scheduler;
        AttentionBank* _attention_bank;
    
    public:

    void setUp(){

        // Initialize the CogServer
        _cogserver = &cogserver();
        config().set("MODULES", "opencog/attention/libattention.so");
        _cogserver->loadModules();
        config().set("MODULES", "libagents.so");

        // loading the AgentsModule
        Module* amod = _cogserver->getModule("opencog::AgentsModule");
        AgentsModule* agmod = static_cast<AgentsModule*>(amod);

        // loading the AtomSpace
        as = &_cogserver->getAtomSpace();

        // initializing the AFRentCollectionAgent
        _afrentcollection_agent = new AFRentCollectionAgent(*_cogserver);
        

        // registering the AFRentCollectionAgent
        _scheduler = &agmod->get_scheduler();
        AbstractFactory<Agent>* afrentcollectionFactory = new Factory<AFRentCollectionAgent, Agent>;
        _scheduler->registerAgent(AFRentCollectionAgent::info().id, afrentcollectionFactory);

        std::cout << "AFRentCollectionAgent registered" << std::endl;
    }
    // function for clearing the memory
     void tearDown()
    {
        delete _afrentcollection_agent;
        _cogserver->stop();
        std::cout << "TearDown completed for AFRentCollectionAgentTest." << std::endl;
    }

    void testSelectTargets(){

        // create sample atoms in atomspace
        Handle a = as->add_node(CONCEPT_NODE, "node1");
        Handle b = as->add_node(CONCEPT_NODE, "node2");
       

        std::cout << "Nodes created" << std::endl;

        // why do we intialize attention bank like this here, why not like cogserver or scheduler"

        AttentionBank& ab = attentionbank(as);
         ab.set_sti(a, 100);
         ab.set_sti(b, 200);
         ab.set_lti(a, 100);
         ab.set_lti(b, 200);
        
       

        std::cout << "Atoms stimulated to bring them into attentional focus." << std::endl;

        HandleSeq targetSet;
        _afrentcollection_agent->selectTargets(targetSet);

        TS_ASSERT_EQUALS(targetSet.size(), 2);
        TS_ASSERT(std::find(targetSet.begin(), targetSet.end(), a) != targetSet.end());
        TS_ASSERT(std::find(targetSet.begin(), targetSet.end(), b) != targetSet.end());
        

        std::cout << "testSelectTargets passed" << std::endl;

    }

  void testCollectRent() {
    // Step 1: Create and stimulate some atoms
    Handle a = as->add_node(CONCEPT_NODE, "RentNode1");
    Handle b = as->add_node(CONCEPT_NODE, "RentNode2");
    Handle c = as->add_node(CONCEPT_NODE, "RentNode3");

    AttentionBank& ab = attentionbank(as);
    ab.set_sti(a, 50000);
    ab.set_sti(b, 20000);
    ab.set_sti(c, 29000);
    ab.set_lti(a, 50000);
    ab.set_lti(b, 20000);
    ab.set_lti(c, 29000);

    std::cout << "STI before rent collection: " 
              << get_sti(a) << ", " << get_sti(b) << ", " << get_sti(c) << std::endl;

    // Step 2: Add atoms to a HandleSeq (targetSet)
    HandleSeq targetSet = {a, b, c};

    // Step 3: Call collectRent in a loop until enough time has passed
    auto start_time = std::chrono::high_resolution_clock::now();
    double required_time_sec = 1.0 / 5.0; // 0.2 seconds (Update frequency: 5Hz)

    while (true) {
    _afrentcollection_agent->collectRent(targetSet);
    
    auto elapsed_time = std::chrono::duration_cast<std::chrono::duration<double>>(
        std::chrono::high_resolution_clock::now() - start_time
    ).count();

    if (elapsed_time >= required_time_sec)
        break;

    std::this_thread::sleep_for(std::chrono::duration<double>(1.0 / 5.0));
}


    std::cout << "STI after rent collection: " 
              << get_sti(a) << ", " << get_sti(b) << ", " << get_sti(c) << std::endl;

    // Step 4: Verify STI has decreased
    TS_ASSERT_LESS_THAN(get_sti(a), 50000); // STI should be lower than before
    TS_ASSERT_LESS_THAN(get_sti(b), 20000);
    TS_ASSERT_LESS_THAN(get_sti(c), 29000);

    std::cout << "testCollectRent passed" << std::endl;
}


};        