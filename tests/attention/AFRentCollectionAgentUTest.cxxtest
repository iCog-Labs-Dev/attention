#include <cxxtest/TestSuite.h>
#include <opencog/attention/AFRentCollectionAgent.h>
#include <opencog/attention/AttentionParamQuery.h>
#include <opencog/atomspace/AtomSpace.h>
#include <opencog/attentionbank/bank/AttentionBank.h>
#include <opencog/cogserver/server/CogServer.h>
#include <opencog/cogserver/modules/agents/AgentsModule.h>
#include <opencog/attentionbank/avalue/AttentionValue.h>
#include <opencog/atoms/truthvalue/SimpleTruthValue.h>
#include <memory>
#include <iostream>

using namespace opencog;

class TestAFRentCollectionAgent : public AFRentCollectionAgent {
public:
    using AFRentCollectionAgent::AFRentCollectionAgent;

    void loadParams() { load_params(); }
    double getSTIAtomRent() const { return STIAtomRent; }
    double getLTIAtomRent() const { return LTIAtomRent; }
    double getTargetSTI() const { return targetSTI; }
    double getSTIFundsBuffer() const { return stiFundsBuffer; }
    double getTargetLTI() const { return targetLTI; }
    double getLTIFundsBuffer() const { return ltiFundsBuffer; }

    // Override selectTargets for debugging purposes
    void selectTargets(HandleSeq& targetSet) override {
        std::cerr << "Debugging selectTargets...\n";
        AFRentCollectionAgent::selectTargets(targetSet);
        std::cerr << "selectTargets found " << targetSet.size() << " targets.\n";
    }
};

class AFRentCollectionAgentUTest : public CxxTest::TestSuite {
private:
    AtomSpace* _as;
    CogServer* _cogserver;
    Scheduler* _scheduler;
    std::shared_ptr<TestAFRentCollectionAgent> _af_agent;

public:
    AFRentCollectionAgentUTest() : _as(nullptr), _cogserver(nullptr), _scheduler(nullptr) {}

    void setUp() {
        _cogserver = &cogserver();
        _as = new AtomSpace();

        // Load necessary modules
        _cogserver->loadModules();

        // Initialize AgentsModule and Scheduler
        AgentsModule* agmod = dynamic_cast<AgentsModule*>(_cogserver->getModule("opencog::AgentsModule"));
        _scheduler = &agmod->get_scheduler();

        // Initialize the test subclass of AFRentCollectionAgent
        _af_agent = std::make_shared<TestAFRentCollectionAgent>(*_cogserver);
        setParameters();
        _af_agent->loadParams();
    }

    void tearDown() {
        if (_scheduler && _af_agent) {
            _scheduler->stopAgent(std::static_pointer_cast<Agent>(_af_agent));
        }
        delete _as;
        _as = nullptr;
    }

    void setParameters() {
        auto _atq = std::make_shared<AttentionParamQuery>(_as);
        _atq->set_param(AttentionParamQuery::rent_starting_sti_rent, 1.0);
        _atq->set_param(AttentionParamQuery::rent_starting_lti_rent, 1.0);
        _atq->set_param(AttentionParamQuery::rent_target_sti_funds, 10000.0);
        _atq->set_param(AttentionParamQuery::rent_sti_funds_buffer, 10000.0);
        _atq->set_param(AttentionParamQuery::rent_target_lti_funds, 10000.0);
        _atq->set_param(AttentionParamQuery::rent_lti_funds_buffer, 10000.0);
    }

    void testSelectTargets() {
        AttentionBank& ab = attentionbank(_as);

        // Add atoms to AtomSpace and set initial STI and LTI values
        Handle atom1 = _as->add_node(CONCEPT_NODE, "Atom1");
        Handle atom2 = _as->add_node(CONCEPT_NODE, "Atom2");

        // Debug: Confirm atom addition
        std::cerr << "Added atom1 and atom2 to AtomSpace.\n";

        // Set LTI and STI values to ensure they are part of attentional focus
        ab.set_lti(atom1, 6);
        ab.set_sti(atom1, 200);
        ab.set_lti(atom2, 5);
        ab.set_sti(atom2, 300);

        HandleSeq targetSet;
        _af_agent->selectTargets(targetSet);

        // Debugging: Check if attentional focus contains the expected nodes
        std::cerr << "Attentional focus should contain 2 targets. Found " << targetSet.size() << " targets.\n";
        for (const auto& target : targetSet) {
            std::cerr << "Target found: " << target << "\n";
        }

        // Assertions
        TS_ASSERT_EQUALS(targetSet.size(), 2);
        TS_ASSERT(std::find(targetSet.begin(), targetSet.end(), atom1) != targetSet.end());
        TS_ASSERT(std::find(targetSet.begin(), targetSet.end(), atom2) != targetSet.end());
    }

    void testCollectRent() {
        AttentionBank& ab = attentionbank(_as);

        // Add atoms and set STI/LTI values using AttentionBank
        Handle atom1 = _as->add_node(CONCEPT_NODE, "Atom1");
        Handle atom2 = _as->add_node(CONCEPT_NODE, "Atom2");

        ab.set_lti(atom1, 6);
        ab.set_sti(atom1, 500);
        ab.set_lti(atom2, 5);
        ab.set_sti(atom2, 300);

        HandleSeq targetSet;
        _af_agent->selectTargets(targetSet);
        _af_agent->collectRent(targetSet);

        // Verify that rent has been deducted correctly
        double stiRent = _af_agent->calculate_STI_Rent();
        double ltiRent = _af_agent->calculate_LTI_Rent();
        TS_ASSERT_LESS_THAN_EQUALS(ab.getTotalSTI(), 10000.0 - stiRent);
        TS_ASSERT_LESS_THAN_EQUALS(ab.getTotalLTI(), 10000.0 - ltiRent);
    }

    void testParameterLoading() {
        TS_ASSERT_EQUALS(_af_agent->getSTIAtomRent(), 1.0);
        TS_ASSERT_EQUALS(_af_agent->getLTIAtomRent(), 1.0);
        TS_ASSERT_EQUALS(_af_agent->getTargetSTI(), 10000.0);
        TS_ASSERT_EQUALS(_af_agent->getSTIFundsBuffer(), 10000.0);
        TS_ASSERT_EQUALS(_af_agent->getTargetLTI(), 10000.0);
        TS_ASSERT_EQUALS(_af_agent->getLTIFundsBuffer(), 10000.0);
    }

    void testCalculateSTIRent() {
        double expectedRent = 0.0; // Assuming STI >= targetSTI
        double calculatedRent = _af_agent->calculate_STI_Rent();
        TS_ASSERT_EQUALS(calculatedRent, expectedRent);
    }

    void testCalculateLTIRent() {
        double expectedRent = 0.0; // Assuming LTI >= targetLTI
        double calculatedRent = _af_agent->calculate_LTI_Rent();
        TS_ASSERT_EQUALS(calculatedRent, expectedRent);
    }
};
