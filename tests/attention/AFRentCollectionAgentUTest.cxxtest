


#include <cxxtest/TestSuite.h>

#include <opencog/attention/AFRentCollectionAgent.h>
#include <opencog/cogserver/modules/agents/Scheduler.h>
#include <opencog/cogserver/server/CogServer.h>
#include <opencog/attentionbank/bank/AttentionBank.h>
#include <opencog/attentionbank/avalue/AttentionValue.h>
#include <opencog/atomspace/AtomSpace.h>
#include <opencog/util/Config.h>
#include <opencog/cogserver/modules/agents/AgentsModule.h>


using namespace opencog;

using namespace std;


class AFRentCollectioAgentUTest : public CxxTest::TestSuite
{
    private:
        AtomSpace* as;
        AFRentCollectionAgent* _afrentcollection_agent;
        CogServer* _cogserver;
        Scheduler* _scheduler;
        AttentionBank* _attention_bank;
    
    public:

    void setUp(){

        // Initialize the CogServer
        _cogserver = &cogserver();
        config().set("MODULES", "opencog/attention/libattention.so");
        _cogserver->loadModules();
        config().set("MODULES", "libagents.so");

        // loading the AgentsModule
        Module* amod = _cogserver->getModule("opencog::AgentsModule");
        AgentsModule* agmod = static_cast<AgentsModule*>(amod);

        // loading the AtomSpace
        as = &_cogserver->getAtomSpace();

        // initializing the AFRentCollectionAgent
        _afrentcollection_agent = new AFRentCollectionAgent(*_cogserver);

        // registering the AFRentCollectionAgent
        _scheduler = &agmod->get_scheduler();
        AbstractFactory<Agent>* afrentcollectionFactory = new Factory<AFRentCollectionAgent, Agent>;
        _scheduler->registerAgent(AFRentCollectionAgent::info().id, afrentcollectionFactory);

        std::cout << "AFRentCollectionAgent registered" << std::endl;
    }
    // function for clearing the memory
     void tearDown()
    {
        delete _afrentcollection_agent;
        _cogserver->stop();
        std::cout << "TearDown completed for AFRentCollectionAgentTest." << std::endl;
    }

    void testSelectTargets(){

        // create sample atoms in atomspace
        Handle h1 = as->add_node(CONCEPT_NODE, "node1");
        Handle h2 = as->add_node(CONCEPT_NODE, "node2");
        Handle h3 = as->add_node(CONCEPT_NODE, "node3");

        std::cout << "Nodes created" << std::endl;

        // why do we intialize attention bank like this here, why not like cogserver or scheduler"

        AttentionBank& ab = attentionbank(as);

        ab.stimulate(h1, 100);
        ab.stimulate(h2, 200);
        ab.stimulate(h3, 300);

        std::cout << "Atoms stimulated to bring them into attentional focus." << std::endl;

        HandleSeq targetSet;
        _afrentcollection_agent->selectTargets(targetSet);

        TS_ASSERT_EQUALS(targetSet.size(), 3);

        TS_ASSERT(std::find(targetSet.begin(), targetSet.end(), h1) != targetSet.end());
        TS_ASSERT(std::find(targetSet.begin(), targetSet.end(), h2) != targetSet.end());
        TS_ASSERT(std::find(targetSet.begin(), targetSet.end(), h3) != targetSet.end());

        std::cout << "testSelectTargets passed" << std::endl;

    }
void testCollectRent() {
    //Create and stimulate some atoms
    Handle h1 = as->add_node(CONCEPT_NODE, "RentNode1");
    Handle h2 = as->add_node(CONCEPT_NODE, "RentNode2");
    Handle h3 = as->add_node(CONCEPT_NODE, "RentNode3");

    AttentionBank& ab = attentionbank(as);

    // Set initial STI and LTI values for the atoms
    ab.set_sti(h1, 300);
    ab.set_sti(h2, 400);
    ab.set_sti(h3, 500);

    ab.set_lti(h1, 1000);
    ab.set_lti(h2, 1200);
    ab.set_lti(h3, 1500);

    // Log initial STI and LTI values
    AttentionValuePtr av1 = get_av(h1);
    AttentionValuePtr av2 = get_av(h2);
    AttentionValuePtr av3 = get_av(h3);

    std::cout << "Initial STI and LTI values:" << std::endl;
    std::cout << "h1 STI: " << av1->getSTI() << ", LTI: " << av1->getLTI() << std::endl;
    std::cout << "h2 STI: " << av2->getSTI() << ", LTI: " << av2->getLTI() << std::endl;
    std::cout << "h3 STI: " << av3->getSTI() << ", LTI: " << av3->getLTI() << std::endl;

    // Add atoms to the target set
    HandleSeq targetSet = {h1, h2, h3};
    std::cout << "Target set for collectRent contains: " << targetSet.size() << " atoms." << std::endl;

    // Ensure sufficient elapsed time
    std::this_thread::sleep_for(std::chrono::milliseconds(1100));

    // Call collectRent to apply changes
    _afrentcollection_agent->collectRent(targetSet);

    // Log STI and LTI values after collectRent
    AttentionValuePtr av1_after = get_av(h1);
    AttentionValuePtr av2_after = get_av(h2);
    AttentionValuePtr av3_after = get_av(h3);

    std::cout << "STI and LTI values after rent collection:" << std::endl;
    std::cout << "h1 STI: " << av1_after->getSTI() << ", LTI: " << av1_after->getLTI() << std::endl;
    std::cout << "h2 STI: " << av2_after->getSTI() << ", LTI: " << av2_after->getLTI() << std::endl;
    std::cout << "h3 STI: " << av3_after->getSTI() << ", LTI: " << av3_after->getLTI() << std::endl;

    // Verify STI and LTI reductions
    TS_ASSERT_LESS_THAN_EQUALS(av1_after->getSTI(), 300);
    TS_ASSERT_LESS_THAN_EQUALS(av2_after->getSTI(), 400);
    TS_ASSERT_LESS_THAN_EQUALS(av3_after->getSTI(), 500);

    TS_ASSERT_LESS_THAN_EQUALS(av1_after->getLTI(), 1000);
    TS_ASSERT_LESS_THAN_EQUALS(av2_after->getLTI(), 1200);
    TS_ASSERT_LESS_THAN_EQUALS(av3_after->getLTI(), 1500);

    //Stimulate STI again after collectRent
    ab.stimulate(h1, 100); // Add STI stimulation
    ab.stimulate(h2, 100);
    ab.stimulate(h3, 100);

    //Increase LTI after collectRent
    ab.set_lti(h1, av1_after->getLTI() + 200);
    ab.set_lti(h2, av2_after->getLTI() + 200);
    ab.set_lti(h3, av3_after->getLTI() + 200);

    AttentionValuePtr av1_final = get_av(h1);
    AttentionValuePtr av2_final = get_av(h2);
    AttentionValuePtr av3_final = get_av(h3);

    std::cout << "STI and LTI values after stimulation:" << std::endl;
    std::cout << "h1 STI: " << av1_final->getSTI() << ", LTI: " << av1_final->getLTI() << std::endl;
    std::cout << "h2 STI: " << av2_final->getSTI() << ", LTI: " << av2_final->getLTI() << std::endl;
    std::cout << "h3 STI: " << av3_final->getSTI() << ", LTI: " << av3_final->getLTI() << std::endl;

    // Ensure STI and LTI values increase after stimulation
    TS_ASSERT_LESS_THAN(av1_after->getSTI(), av1_final->getSTI());
    TS_ASSERT_LESS_THAN(av2_after->getSTI(), av2_final->getSTI());
    TS_ASSERT_LESS_THAN(av3_after->getSTI(), av3_final->getSTI());

    TS_ASSERT_LESS_THAN(av1_after->getLTI(), av1_final->getLTI());
    TS_ASSERT_LESS_THAN(av2_after->getLTI(), av2_final->getLTI());
    TS_ASSERT_LESS_THAN(av3_after->getLTI(), av3_final->getLTI());

    std::cout << "testCollectRent completed." << std::endl;
}








};        
