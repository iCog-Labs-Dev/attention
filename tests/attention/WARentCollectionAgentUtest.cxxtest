// WARentCollectionAgentUTest.cpp

#include <cxxtest/TestSuite.h>
#include <chrono>
#include <thread>
#include <algorithm>
#include <iostream>

#include <opencog/cogserver/server/CogServer.h>
#include <opencog/atomspace/AtomSpace.h>
#include <opencog/cogserver/modules/agents/AgentsModule.h>
#include <opencog/cogserver/modules/agents/Scheduler.h>
#include <opencog/attentionbank/bank/AttentionBank.h>
#include <opencog/attention/WARentCollectionAgent.h>
#include <opencog/util/Config.h>



using namespace opencog;
using namespace std;
using namespace std::chrono;

class WARentCollectionAgentUTest : public CxxTest::TestSuite {
private:
    AtomSpace* as;
    WARentCollectionAgent* _wagent;
    CogServer* _cogserver;
    Scheduler* _scheduler;

public:
    void setUp() {
        // Initialize the CogServer
        _cogserver = &cogserver();
        config().set("MODULES", "opencog/attention/libattention.so");
        _cogserver->loadModules();
        config().set("MODULES", "libagents.so");

        // Load the AgentsModule
        Module* amod = _cogserver->getModule("opencog::AgentsModule");
        AgentsModule* agmod = static_cast<AgentsModule*>(amod);
        _scheduler = &agmod->get_scheduler();

        // Get the AtomSpace
        as = &_cogserver->getAtomSpace();

        // Initialize the WARentCollectionAgent
        _wagent = new WARentCollectionAgent(*_cogserver);

        // Register the WARentCollectionAgent with the scheduler
        AbstractFactory<Agent>* warentFactory = new Factory<WARentCollectionAgent, Agent>;
        _scheduler->registerAgent(WARentCollectionAgent::info().id, warentFactory);

        std::cout << "WARentCollectionAgent registered" << std::endl;
    }

    void tearDown() {
        delete _wagent;
        _cogserver->stop();
        std::cout << "TearDown completed for WARentCollectionAgentUTest." << std::endl;
    }

    void testSelectTargets() {
        // Create a couple of sample atoms in the AtomSpace.
        Handle a = as->add_node(CONCEPT_NODE, "node1");
        Handle b = as->add_node(CONCEPT_NODE, "node2");

        // Stimulate atoms so they have valid STI and LTI values.
        AttentionBank& ab = attentionbank(as);
        ab.set_sti(a, 100);
        ab.set_sti(b, 200);
        ab.set_lti(a, 100);
        ab.set_lti(b, 200);

        std::cout << "Atoms created and stimulated for target selection." << std::endl;

        // Call WARentCollectionAgent::selectTargets to choose one atom.
        HandleSeq targetSet;
         targetSet = { a,b };
        _wagent->selectTargets(targetSet);

        // Expect one target to be selected (getRandomAtomNotInAF returns one atom).
       // TS_ASSERT_EQUALS(targetSet.size(), 1);
        //TS_ASSERT((targetSet[0] == a) || (targetSet[0] == b));
        std::cout << "testSelectTargets passed" << std::endl;
    }

    void testCollectRent() {
        // Create a single atom for rent collection testing.
        Handle a = as->add_node(CONCEPT_NODE, "RentNode1");
        Handle b = as->add_node(CONCEPT_NODE, "RentNode2");
        Handle c = as->add_node(CONCEPT_NODE, "RentNode3");
        AttentionBank& ab = attentionbank(as);
        ab.set_sti(a, 100);
        ab.set_lti(a, 100);
        ab.set_sti(c, 100);
        ab.set_sti(b, 200);
        ab.set_lti(c, 100);
        ab.set_lti(b, 200);
        // For this test, we call collectRent directly on a known target.
    HandleSeq targetSet = { a };
 _wagent->collectRent(targetSet);
 // float dummy = _wagent->_sdac.elapsed_time(a);
      //  (void)dummy; // suppress unused variable warning
        // Wait briefly so that elapsed time (measured inside WARentCollectionAgent)
        // is nonzero. This ensures that the scaling factor in rent collection is applied.
        std::this_thread::sleep_for(milliseconds(500));

       double initial_sti = get_sti(a);
    double initial_lti = get_lti(a);
  

        // Call collectRent to deduct rent from the atom.
        _wagent->collectRent(targetSet);

        double final_sti = get_sti(a);
        double final_lti = get_lti(a);
     

        // Verify that the rent has been collected (the values are decreased).
       TS_ASSERT_LESS_THAN(final_sti, initial_sti);
     TS_ASSERT_LESS_THAN(final_lti, initial_lti);
       std::cout << "testCollectRent passed" << std::endl;
    }


    
};
