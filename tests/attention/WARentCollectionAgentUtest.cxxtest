// WARentCollectionAgentUTest.cpp

#include <cxxtest/TestSuite.h>
#include <chrono>
#include <thread>
#include <algorithm>
#include <iostream>

#include <opencog/cogserver/server/CogServer.h>
#include <opencog/atomspace/AtomSpace.h>
#include <opencog/cogserver/modules/agents/AgentsModule.h>
#include <opencog/cogserver/modules/agents/Scheduler.h>
#include <opencog/attentionbank/bank/AttentionBank.h>
#include <opencog/attention/WARentCollectionAgent.h>
#include <opencog/attentionbank/bank/StochasticImportanceDiffusion.h>
#include <opencog/util/Config.h>



using namespace opencog;
using namespace std;
using namespace std::chrono;

class WARentCollectionAgentUTest : public CxxTest::TestSuite {
private:
    AtomSpace* as;
    WARentCollectionAgent* _wagent;
    CogServer* _cogserver;
    Scheduler* _scheduler;

public:
    void setUp() {
        // Initialize the CogServer
        _cogserver = &cogserver();
        config().set("MODULES", "opencog/attention/libattention.so");
        _cogserver->loadModules();
        config().set("MODULES", "libagents.so");

        // Load the AgentsModule
        Module* amod = _cogserver->getModule("opencog::AgentsModule");
        AgentsModule* agmod = static_cast<AgentsModule*>(amod);
        _scheduler = &agmod->get_scheduler();

        // Get the AtomSpace
        as = &_cogserver->getAtomSpace();

        // Initialize the WARentCollectionAgent
        _wagent = new WARentCollectionAgent(*_cogserver);

        // Register the WARentCollectionAgent with the scheduler
        AbstractFactory<Agent>* warentFactory = new Factory<WARentCollectionAgent, Agent>;
        _scheduler->registerAgent(WARentCollectionAgent::info().id, warentFactory);

        std::cout << "WARentCollectionAgent registered" << std::endl;
    }

    void tearDown() {
        delete _wagent;
        _cogserver->stop();
        std::cout << "TearDown completed for WARentCollectionAgentUTest." << std::endl;
    }


void testCollectRent() {
    // Create atoms for rent collection testing
    Handle a = as->add_node(CONCEPT_NODE, "RentNode1");
    Handle b = as->add_node(CONCEPT_NODE, "RentNode2");
    Handle c = as->add_node(CONCEPT_NODE, "RentNode3");
    Handle d = as->add_node(CONCEPT_NODE, "RentNode4");
    Handle e = as->add_node(CONCEPT_NODE, "RentNode5");

    AttentionBank& ab = attentionbank(as);
    ab.stimulate(c, 3000.0);
    ab.stimulate(d, 1500.0);
    ab.stimulate(e, 290.0);
    ab.stimulate(b, 50.0);
    ab.stimulate(a, 5.0);
    TS_ASSERT_EQUALS(get_sti(a), 33.725); 
    TS_ASSERT_EQUALS(get_sti(b), 355.0);
    TS_ASSERT_EQUALS(get_sti(c), 60000.0);
    TS_ASSERT_EQUALS(get_sti(d), 30000.0);
    TS_ASSERT_EQUALS(get_sti(e), 2900.0);

    // Reference StochasticDiffusionAmountCalculator with the correct namespace
    opencog::ecan::StochasticDiffusionAmountCalculator& sdac = _wagent->_sdac;

    HandleSeq targetSet;
         _wagent->selectTargets(targetSet);

    TS_ASSERT_EQUALS(targetSet.size(), 1);
    sdac.update_bin(a);
    sdac.update_bin(b);
    sdac.update_bin(c);
    sdac.update_bin(d);
    sdac.update_bin(e);



    // Wait briefly so that elapsed time is nonzero
    std::this_thread::sleep_for(std::chrono::milliseconds(500));


    // Call collectRent to deduct rent from the atom
  
    _wagent->collectRent(targetSet);
    TS_ASSERT_LESS_THAN(get_sti(a),33.725); //should be lower sti than before
    TS_ASSERT_EQUALS(get_sti(b), 355.0);
    TS_ASSERT_EQUALS(get_sti(c), 60000.0);
    TS_ASSERT_EQUALS(get_sti(d), 30000.0);
    TS_ASSERT_EQUALS(get_sti(e), 2900.0);

    std::cout << "testCollectRent passed" << std::endl;
}
    
};
