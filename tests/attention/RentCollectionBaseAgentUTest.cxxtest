#include <cxxtest/TestSuite.h>
#include <opencog/attention/RentCollectionBaseAgent.h>
#include <opencog/attention/AttentionParamQuery.h>
#include <opencog/atomspace/AtomSpace.h>
#include <opencog/attentionbank/bank/AttentionBank.h>
#include <opencog/cogserver/server/CogServer.h>
#include <opencog/cogserver/modules/agents/AgentsModule.h>
#include <opencog/cogserver/modules/agents/Scheduler.h>
#include <opencog/util/Config.h>
#include <opencog/util/Logger.h>
#include <memory>

using namespace opencog;
// DummyRentCollectionAgent is used here to instantiate and 
// test abstract methods from RentCollectionBaseAgent
class DummyRentCollectionAgent : public RentCollectionBaseAgent {
public:
    DummyRentCollectionAgent(CogServer& cs) : RentCollectionBaseAgent(cs) {}

    void selectTargets(HandleSeq &targetSetOut) override {
        // Dummy implementation for selecting targets
        Handle atom1 = _as->add_node(CONCEPT_NODE, "DummyAtom1");
        Handle atom2 = _as->add_node(CONCEPT_NODE, "DummyAtom2");
        targetSetOut.push_back(atom1);
        targetSetOut.push_back(atom2);
    }

    void collectRent(HandleSeq& targetSet) override {
        // Dummy implementation for collecting rent
        AttentionBank& ab = attentionbank(_as);
        for (const auto& target : targetSet) {
            // Directly manipulate the STI value in the AttentionBank
            ab.set_sti(target, 0); 
        }
    }

    // Expose protected members for testing
    void loadParams() { load_params(); }
    double getSTIAtomRent() const { return STIAtomRent; }
    double getLTIAtomRent() const { return LTIAtomRent; }
    double getTargetSTI() const { return targetSTI; }
    double getSTIFundsBuffer() const { return stiFundsBuffer; }
    double getTargetLTI() const { return targetLTI; }
    double getLTIFundsBuffer() const { return ltiFundsBuffer; }

    const ClassInfo& classinfo() const override {
        static ClassInfo ci("DummyRentCollectionAgent");
        return ci;
    }
};

class RentCollectionAgentUTest : public CxxTest::TestSuite {
private:
    AtomSpace* _as;
    CogServer* _cogserver;
    Scheduler* _scheduler;
    std::shared_ptr<AttentionParamQuery> _atq;  //Declare `_atq` as a class member
    std::shared_ptr<DummyRentCollectionAgent> _dummy_agent;

public:
    RentCollectionAgentUTest() : _as(nullptr), _cogserver(nullptr), _scheduler(nullptr) {}

    void setUp() {
        _cogserver = &cogserver();
        if (_as) {
            delete _as; // Ensure previous AtomSpace is deleted
        }
        _as = new AtomSpace();

        // Configure and load necessary modules
        config().set("MODULES", "opencog/attention/libattention.so");
        _cogserver->loadModules();

        Module* amod = _cogserver->getModule("opencog::AgentsModule");
        AgentsModule* agmod = dynamic_cast<AgentsModule*>(amod);
        _scheduler = &agmod->get_scheduler();

        // Properly initialize `_atq`
        _atq = std::make_shared<AttentionParamQuery>(_as);
        
        // Create DummyRentCollectionAgent
        _dummy_agent = std::make_shared<DummyRentCollectionAgent>(*_cogserver);
        _dummy_agent->loadParams(); 
    }

   void testCalculateSTIRent() {
    //Explicitly reload parameters
    _dummy_agent->loadParams(); 

    
    AttentionBank& ab = attentionbank(_as);
    Handle a= _as->add_node(CONCEPT_NODE, "Atom1");
    Handle b= _as->add_node(CONCEPT_NODE, "Atom2");
    Handle c= _as->add_node(CONCEPT_NODE, "Atom3");

       
    double calculatedBeforeSTIRent = _dummy_agent->calculate_STI_Rent();
    double calculatedBeforeLTIRent = _dummy_agent->calculate_LTI_Rent();
  
  //Calculate rent before stimulating
    TS_ASSERT_EQUALS(calculatedBeforeSTIRent,0.0); 
    TS_ASSERT_EQUALS(calculatedBeforeLTIRent,0.0);
    
    ab.stimulate(a, 3000.0);
    ab.stimulate(b, 1500.0);
    ab.stimulate(c, 290.0);

    double calculatedAfterSTIRent = _dummy_agent->calculate_STI_Rent();
    double calculatedAfterLTIRent = _dummy_agent->calculate_LTI_Rent();

    //Calculate rent after stimulating
    // Verify rent is greater than 0
    TS_ASSERT(calculatedAfterSTIRent > 0.0);
    TS_ASSERT(calculatedAfterLTIRent > 0.0);
   
    std::cout << "Calculated STI Rent: " << calculatedAfterSTIRent << std::endl;
    std::cout << "Calculated LTI Rent: " << calculatedAfterLTIRent << std::endl;
}



};