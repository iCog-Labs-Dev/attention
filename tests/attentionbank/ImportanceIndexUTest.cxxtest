#include <cxxtest/TestSuite.h>
#include <opencog/attentionbank/bank/ImportanceIndex.h>
#include <opencog/attentionbank/avalue/AttentionValue.h>
#include <opencog/attentionbank/bank/AttentionBank.h>
#include <opencog/atomspace/AtomSpace.h>
#include <opencog/atoms/base/Handle.h>

using namespace opencog;

class ImportanceIndexUTest : public CxxTest::TestSuite {
private:
    ImportanceIndex* importanceIndex;
    AtomSpace* atomSpace;

    AttentionValuePtr createAttentionValue(AttentionValue::sti_t sti) {
        return AttentionValue::createAV(sti, 20, 5); // Example LTI and VLTI
    }

public:
    void setUp() override {
        importanceIndex = new ImportanceIndex();
        atomSpace = new AtomSpace();
    }

    void tearDown() override {
        delete importanceIndex;
        delete atomSpace;
    }

   /**
 * Ensures that an atom is moved to the correct bin based on its updated
 * STI value and that it is removed from the old bin.
 */
void testUpdateImportance() {
    Handle h1 = atomSpace->add_node(CONCEPT_NODE, "Atom1");
    TS_ASSERT(h1 != Handle::UNDEFINED);

    auto oldAv = createAttentionValue(0); 
    auto newAv = createAttentionValue(50);

    // Calculate expected bins using the public wrapper
    size_t oldBin = importanceIndex->importanceBin(oldAv->getSTI());
    size_t newBin = importanceIndex->importanceBin(newAv->getSTI());

    // Update the importance
    importanceIndex->updateImportance(h1, oldAv, newAv);

    // Verify the atom is no longer in the old bin
    UnorderedHandleSet oldBinContents;
    importanceIndex->getContent(oldBin, std::inserter(oldBinContents, oldBinContents.end()));
   TS_ASSERT_EQUALS(oldBinContents.size(), 0);

    // Verify the atom is now in the correct new bin
    UnorderedHandleSet newBinContents;
    importanceIndex->getContent(newBin, std::inserter(newBinContents, newBinContents.end()));
    TS_ASSERT_EQUALS(newBinContents.size(), 1);
    TS_ASSERT(newBinContents.find(h1) != newBinContents.end());
}


/**
     * Verifies that an atom can be successfully removed from the index and 
     * is no longer present in its assigned bin.
     */
void testRemoveAtom() {
    // Create a concept node
    Handle h1 = atomSpace->add_node(CONCEPT_NODE, "Atom1");
    TS_ASSERT(h1 != Handle::UNDEFINED);

    // Define an STI value and calculate the corresponding bin
    AttentionValue::sti_t stiValue = 50;
    auto av = AttentionValue::createAV(stiValue, 20, 5); // Example LTI and VLTI
    size_t binIndex = importanceIndex->importanceBin(stiValue);

    // Manually insert the atom into the importance index
    importanceIndex->_index.insert(binIndex, h1);
    set_av(atomSpace, h1, av);

    // Verify the atom is in the calculated bin
    TS_ASSERT_EQUALS(importanceIndex->size(binIndex), 1);

    // Remove the atom
    importanceIndex->removeAtom(h1);

    // Verify the atom is not present after removal
    TS_ASSERT_EQUALS(importanceIndex->size(binIndex), 0);
}


/**
     * Ensures that a random atom can be retrieved from the index, and 
     * that it belongs to the set of added atoms.
     */
    void testGetRandomAtom() {
        Handle h1 = atomSpace->add_node(CONCEPT_NODE, "Atom1");
        Handle h2 = atomSpace->add_node(CONCEPT_NODE, "Atom2");

        importanceIndex->updateImportance(h1, createAttentionValue(0), createAttentionValue(10));
        importanceIndex->updateImportance(h2, createAttentionValue(0), createAttentionValue(50));

        auto randomAtom = importanceIndex->getRandomAtom();
        TS_ASSERT(randomAtom != Handle::UNDEFINED);
        TS_ASSERT(randomAtom == h1 || randomAtom == h2);
    }
    


    /**
     * Verifies that the bins containing the smallest and largest STI values 
     * can be correctly identified and retrieved.
     */
    void testGetMinMaxBinContents() {
        Handle h1 = atomSpace->add_node(CONCEPT_NODE, "Atom1");
        Handle h2 = atomSpace->add_node(CONCEPT_NODE, "Atom2");

        importanceIndex->updateImportance(h1, createAttentionValue(0), createAttentionValue(10));
        importanceIndex->updateImportance(h2, createAttentionValue(0), createAttentionValue(100));

        auto minContents = importanceIndex->getMinBinContents();
        auto maxContents = importanceIndex->getMaxBinContents();

        TS_ASSERT_EQUALS(minContents.size(), 1);
        TS_ASSERT_EQUALS(maxContents.size(), 1);
        TS_ASSERT(minContents.find(h1) != minContents.end());
        TS_ASSERT(maxContents.find(h2) != maxContents.end());
    }

    /**
     * Validates that atoms within a specific STI range can be retrieved 
     * correctly using the getHandleSet method.
     */
    void testGetHandleSet() {
        Handle h1 = atomSpace->add_node(CONCEPT_NODE, "Atom1");
        Handle h2 = atomSpace->add_node(CONCEPT_NODE, "Atom2");

        importanceIndex->updateImportance(h1, createAttentionValue(0), createAttentionValue(10));
        importanceIndex->updateImportance(h2, createAttentionValue(0), createAttentionValue(50));

        auto result = importanceIndex->getHandleSet(0, 20);
        TS_ASSERT_EQUALS(result.size(), 1);
        TS_ASSERT(result.find(h1) != result.end());

        result = importanceIndex->getHandleSet(0, 100);
        TS_ASSERT_EQUALS(result.size(), 2);
    }

    /**
     * Ensures that the bin size reflects the correct number of bins in use 
     * after adding an atom.
     */
    void testBinSize() {
        TS_ASSERT_EQUALS(importanceIndex->bin_size(), 0);

        Handle h1 = atomSpace->add_node(CONCEPT_NODE, "Atom");
        auto av = createAttentionValue(50);

        importanceIndex->updateImportance(h1, createAttentionValue(0), av);

        TS_ASSERT(importanceIndex->bin_size() > 0);
    }
};
